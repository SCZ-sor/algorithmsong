# åŸºç¡€ç®—æ³•

## åŒºé—´å³ç«¯ç‚¹ç»“æ„ä½“å°äºå·é‡è½½

```c++
struct R {
    int l,r;
    bool operator < (const R & W) const{
        return r < W.r;
    }
}a[N];
```

ä¹Ÿå¯ä»¥lambda

```c++
sort(sg, sg + n, [&](Sg a, Sg b) {
        return a.r < b.r;
});
```



## __int128

è¯»å…¥

```c++
__int128 read() {
    string scan;
    cin >> scan;
    __int128 res = 0;
    for (char ch : scan) res = res * 10 + (ch - '0');
    return res;
}

```

æ‰“å°

```c++
void println(__int128 num) {
    print(num);
    putchar('\n');
}
```



## å¿«è¯»

```cpp
#define ll long long
inline ll read() {
	ll s = 0, w = 1;
	char c = getchar();
	while (c < '0' || c > '9') {if (c == '-') w = -1; c = getchar();}
	while (c >= '0' && c <= '9') s = (s << 3) + (s << 1) + (c ^ 48), c = getchar();
	return s * w;
}
```

## å½’æ’

```c++
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;
    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];
    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];
    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```

## æ•´æ•°äºŒåˆ†

```c++
bool check(int x) {/* ... */} // æ£€æŸ¥xæ˜¯å¦æ»¡è¶³æŸç§æ€§è´¨
// åŒºé—´[l, r]è¢«åˆ’åˆ†æˆ[l, mid]å’Œ[mid + 1, r]æ—¶ä½¿ç”¨ï¼š
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()åˆ¤æ–­midæ˜¯å¦æ»¡è¶³æ€§è´¨
        else l = mid + 1;
    }
    return l;
}
// åŒºé—´[l, r]è¢«åˆ’åˆ†æˆ[l, mid - 1]å’Œ[mid, r]æ—¶ä½¿ç”¨ï¼š
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```

## æµ®ç‚¹æ•°äºŒåˆ†ç®—æ³•æ¨¡æ¿ 

```c++
bool check(double x) {/* ... */} // æ£€æŸ¥xæ˜¯å¦æ»¡è¶³æŸç§æ€§è´¨
double bsearch_3(double l, double r)
{
    const double eps = 1e-6;   // eps è¡¨ç¤ºç²¾åº¦ï¼Œå–å†³äºé¢˜ç›®å¯¹ç²¾åº¦çš„è¦æ±‚
    while (r - l > eps)
    {
        double mid = (l + r) / 2;
        if (check(mid)) r = mid;
        else l = mid;
    }
    return l;
}
```

## é«˜ç²¾åŠ 

```cpp
const int N = 505;
int a[N],b[N],c[N];
string sa,sb;
int la,lb,lc;

void add(int a[],int b[],int c[]){
    for(int i = 1 ; i <= lc ; i ++ ){
        c[i] += a[i] + b[i];
        c[i + 1] += c[i] / 10;
        c[i] %= 10;
    }
    if(c[lc + 1]) lc ++ ;
}

signed main(){
    cin >> sa >> sb ;
    la = sa.size(),lb = sb.size(),lc = max(la,lb);
    for (int i = 1 ; i <= la ; i ++ ) a[i] = sa[la - i] - '0';
    for (int i = 1 ; i <= lb ; i ++ ) b[i] = sb[lb - i] - '0';
    add(a,b,c);
    for(int i = lc ; i >= 1 ;i -- ) printf("%d",c[i]);
    return 0;
}
```

## é«˜ç²¾å‡

```cpp
const int N = 2e5;
int a[N],b[N],c[N];
string sa,sb;
int la,lb,lc;

bool cmp(int A[],int B[]){
    if(la != lb) return la > lb;
    for(int i = lc ; i <= 1 ; i -- ){
        if(A[i] != B[i]) return A[i] > B[i];
    }
    return true;
}

void sub(int A[],int B[],int C[]){
    for (int i = 1; i <= lc; ++i) {
        if(A[i] < B[i]){
            A[i + 1] -= 1;
            A[i] += 10;
        }
        C[i] = A[i] - B[i];
    }
    while(lc > 1 && C[lc] == 0) lc -- ;
}
signed main(){
    cin >> sa >> sb;
    la = sa.size(),lb = sb.size(),lc = max(la,lb);
    for(int  i = 1 ; i <= la ; i ++ ) a[i] = sa[la - i] - '0';
    for(int  i = 1 ; i <= lb ; i ++ ) b[i] = sb[lb - i] - '0';
    if(!cmp(a,b)){swap(a,b),cout << '-';}
    sub(a,b,c);
    for(int i = lc ; i >= 1 ;i -- ){
        cout << c[i];
    }
    return 0;
}
```

## é«˜ç²¾ä¹˜

```cpp
const int N = 1e5 + 10;
int a[N], b[N], c[N*2];
string sa, sb;
int la, lb, lc;
void mul(int a[], int b[], int c[]) {
    memset(c, 0, sizeof(int)*N*2);
    for(int i = 1; i <= la; i++) {
        for(int j = 1; j <= lb; j++) {
            c[i+j-1] += a[i] * b[j];
            c[i+j] += c[i+j-1] / 10;
            c[i+j-1] %= 10;
        }
    }
    lc = la + lb;
    while(lc > 1 && c[lc] == 0) lc--;
}
signed main() {
    cin >> sa >> sb;
    la = sa.size(), lb = sb.size();
    for(int i = 1; i <= la; i++) a[i] = sa[la-i] - '0';
    for(int i = 1; i <= lb; i++) b[i] = sb[lb-i] - '0';
    mul(a, b, c);
    for(int i = lc; i >= 1; i--) printf("%d", c[i]);
    return 0;
}
```

## ä¸€ç»´å‰ç¼€å’Œ

```c++
S[i] = a[1] + a[2] + ... a[i]
a[l] + ... + a[r] = S[r] - S[l - 1]
```

## äºŒç»´å‰ç¼€å’Œ 

```c++
S[i, j] = ç¬¬iè¡Œjåˆ—æ ¼å­å·¦ä¸Šéƒ¨åˆ†æ‰€æœ‰å…ƒç´ çš„å’Œ
ä»¥(x1, y1)ä¸ºå·¦ä¸Šè§’ï¼Œ(x2, y2)ä¸ºå³ä¸‹è§’çš„å­çŸ©é˜µçš„å’Œä¸ºï¼š
S[x2, y2] - S[x1 - 1, y2] - S[x2, y1 - 1] + S[x1 - 1, y1 - 1]
```

## ä¸€ç»´å·®åˆ† 

```c++
ç»™åŒºé—´[l, r]ä¸­çš„æ¯ä¸ªæ•°åŠ ä¸Šcï¼šB[l] += c, B[r + 1] -= c
```

## äºŒç»´å·®åˆ†

```c++
ç»™ä»¥(x1, y1)ä¸ºå·¦ä¸Šè§’ï¼Œ(x2, y2)ä¸ºå³ä¸‹è§’çš„å­çŸ©é˜µä¸­çš„æ‰€æœ‰å…ƒç´ åŠ ä¸Šcï¼š
S[x1, y1] += c, S[x2 + 1, y1] -= c, S[x1, y2 + 1] -= c, S[x2 + 1, y2 + 1] += c
```

ä½è¿ç®— 

```c++
æ±‚nçš„ç¬¬kä½æ•°å­—: n >> k & 1
è¿”å›nçš„æœ€åä¸€ä½1ï¼šlowbit(n) = n & -n
```

## ç¦»æ•£åŒ–

```c++
vector<int> alls; // å­˜å‚¨æ‰€æœ‰å¾…ç¦»æ•£åŒ–çš„å€¼
sort(alls.begin(), alls.end()); // å°†æ‰€æœ‰å€¼æ’åº
alls.erase(unique(alls.begin(), alls.end()), alls.end());   // å»æ‰é‡å¤å…ƒç´ 
// äºŒåˆ†æ±‚å‡ºxå¯¹åº”çš„ç¦»æ•£åŒ–çš„å€¼
int find(int x) // æ‰¾åˆ°ç¬¬ä¸€ä¸ªå¤§äºç­‰äºxçš„ä½ç½®
{
    int l = 0, r = alls.size() - 1;
    while (l < r)
    {
        int mid = l + r >> 1;
        if (alls[mid] >= x) r = mid;
        else l = mid + 1;
    }
    return r + 1; // æ˜ å°„åˆ°1, 2, ...n
}
```

## åŒºé—´åˆå¹¶

```c++
// å°†æ‰€æœ‰å­˜åœ¨äº¤é›†çš„åŒºé—´åˆå¹¶
void merge(vector<PII> &segs)
{
    vector<PII> res;

sort(segs.begin(), segs.end());
int st = -2e9, ed = -2e9;
for (auto seg : segs)
    if (ed < seg.first)
    {
        if (st != -2e9) res.push_back({st, ed});
        st = seg.first, ed = seg.second;
    }
    else ed = max(ed, seg.second);

if (st != -2e9) res.push_back({st, ed});

segs = res;

}
```

# æ•°æ®ç»“æ„

## å•é“¾è¡¨

```c++
// headå­˜å‚¨é“¾è¡¨å¤´ï¼Œe[]å­˜å‚¨èŠ‚ç‚¹çš„å€¼ï¼Œne[]å­˜å‚¨èŠ‚ç‚¹çš„nextæŒ‡é’ˆï¼Œidxè¡¨ç¤ºå½“å‰ç”¨åˆ°äº†å“ªä¸ªèŠ‚ç‚¹
int head, e[N], ne[N], idx;
// åˆå§‹åŒ–
void init()
{
    head = -1;
    idx = 0;
}
// åœ¨é“¾è¡¨å¤´æ’å…¥ä¸€ä¸ªæ•°a
void insert(int a)
{
    e[idx] = a, ne[idx] = head, head = idx ++ ;
}
// å°†å¤´ç»“ç‚¹åˆ é™¤ï¼Œéœ€è¦ä¿è¯å¤´ç»“ç‚¹å­˜åœ¨
void remove()
{
    head = ne[head];
}
```

## åŒé“¾è¡¨ 

```c++
// e[]è¡¨ç¤ºèŠ‚ç‚¹çš„å€¼ï¼Œl[]è¡¨ç¤ºèŠ‚ç‚¹çš„å·¦æŒ‡é’ˆï¼Œr[]è¡¨ç¤ºèŠ‚ç‚¹çš„å³æŒ‡é’ˆï¼Œidxè¡¨ç¤ºå½“å‰ç”¨åˆ°äº†å“ªä¸ªèŠ‚ç‚¹
int e[N], l[N], r[N], idx;
// åˆå§‹åŒ–
void init()
{
    //0æ˜¯å·¦ç«¯ç‚¹ï¼Œ1æ˜¯å³ç«¯ç‚¹
    r[0] = 1, l[1] = 0;
    idx = 2;
}

// åœ¨èŠ‚ç‚¹açš„å³è¾¹æ’å…¥ä¸€ä¸ªæ•°x
void insert(int a, int x)
{
    e[idx] = x;
    l[idx] = a, r[idx] = r[a];
    l[r[a]] = idx, r[a] = idx ++ ;
}

// åˆ é™¤èŠ‚ç‚¹a
void remove(int a)
{
    l[r[a]] = l[a];
    r[l[a]] = r[a];
}
```

## å•è°ƒæ ˆ 

å¸¸è§æ¨¡å‹ï¼šæ‰¾å‡ºæ¯ä¸ªæ•°å·¦è¾¹ç¦»å®ƒæœ€è¿‘çš„æ¯”å®ƒå¤§/å°çš„æ•°

```c++
int tt = 0;
for (int i = 1; i <= n; i ++ )
{
    while (tt && check(stk[tt], i)) tt -- ;
    stk[ ++ tt] = i;
}
```

## å•è°ƒé˜Ÿåˆ— 

å¸¸è§æ¨¡å‹ï¼šæ‰¾å‡ºæ»‘åŠ¨çª—å£ä¸­çš„æœ€å¤§å€¼/æœ€å°å€¼

```c++
int hh = 0, tt = -1;
for (int i = 0; i < n; i ++ )
{
    while (hh <= tt && check_out(q[hh])) hh ++ ;  // åˆ¤æ–­é˜Ÿå¤´æ˜¯å¦æ»‘å‡ºçª—å£
    while (hh <= tt && check(q[tt], i)) tt -- ;
    q[ ++ tt] = i;
}
```

## KMP 

```cpp
 // s[]æ˜¯é•¿æ–‡æœ¬ï¼Œp[]æ˜¯æ¨¡å¼ä¸²ï¼Œnæ˜¯sçš„é•¿åº¦ï¼Œmæ˜¯pçš„é•¿åº¦
    æ±‚æ¨¡å¼ä¸²çš„nextæ•°ç»„ï¼š
    for (int i = 2, j = 0; i <= m; i ++ )
    {
        while (j && p[i] != p[j + 1]) j = ne[j];
        if (p[i] == p[j + 1]) j ++ ;
        ne[i] = j;
    }
// åŒ¹é…
for (int i = 1, j = 0; i <= n; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == m)
    {
        j = ne[j];
        // åŒ¹é…æˆåŠŸåçš„é€»è¾‘
    }
}
```

## Trieæ ‘

```c++
 int son[N][26], cnt[N], idx;
    // 0å·ç‚¹æ—¢æ˜¯æ ¹èŠ‚ç‚¹ï¼Œåˆæ˜¯ç©ºèŠ‚ç‚¹
    // son[][]å­˜å‚¨æ ‘ä¸­æ¯ä¸ªèŠ‚ç‚¹çš„å­èŠ‚ç‚¹
    // cnt[]å­˜å‚¨ä»¥æ¯ä¸ªèŠ‚ç‚¹ç»“å°¾çš„å•è¯æ•°é‡
// æ’å…¥ä¸€ä¸ªå­—ç¬¦ä¸²
void insert(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) son[p][u] = ++ idx;
        p = son[p][u];
    }
    cnt[p] ++ ;
}
// æŸ¥è¯¢å­—ç¬¦ä¸²å‡ºç°çš„æ¬¡æ•°
int query(char *str)
{
    int p = 0;
    for (int i = 0; str[i]; i ++ )
    {
        int u = str[i] - 'a';
        if (!son[p][u]) return 0;
        p = son[p][u];
    }
    return cnt[p];
}
```

## å¹¶æŸ¥é›† 

### (1)æœ´ç´ å¹¶æŸ¥é›†ï¼š

```cpp
int p[N]; //å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹
// è¿”å›xçš„ç¥–å®—èŠ‚ç‚¹
int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
// åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n
for (int i = 1; i <= n; i ++ ) p[i] = i;
// åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š
p[find(a)] = find(b);
```

### (2)ç»´æŠ¤sizeçš„å¹¶æŸ¥é›†ï¼š

```cpp
int p[N], size[N];
//p[]å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹, size[]åªæœ‰ç¥–å®—èŠ‚ç‚¹çš„æœ‰æ„ä¹‰ï¼Œè¡¨ç¤ºç¥–å®—èŠ‚ç‚¹æ‰€åœ¨é›†åˆä¸­çš„ç‚¹çš„æ•°é‡
// è¿”å›xçš„ç¥–å®—èŠ‚ç‚¹
int find(int x)
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
// åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n
for (int i = 1; i <= n; i ++ )
{
    p[i] = i;
    size[i] = 1;
}
// åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š
size[find(b)] += size[find(a)];
p[find(a)] = find(b);
```

### (3)ç»´æŠ¤åˆ°ç¥–å®—èŠ‚ç‚¹è·ç¦»çš„å¹¶æŸ¥é›†ï¼š

```cpp
int p[N], d[N];
//p[]å­˜å‚¨æ¯ä¸ªç‚¹çš„ç¥–å®—èŠ‚ç‚¹, d[x]å­˜å‚¨xåˆ°p[x]çš„è·ç¦»
// è¿”å›xçš„ç¥–å®—èŠ‚ç‚¹
int find(int x)
{
    if (p[x] != x)
    {
        int u = find(p[x]);
        d[x] += d[p[x]];
        p[x] = u;
    }
    return p[x];
}
// åˆå§‹åŒ–ï¼Œå‡å®šèŠ‚ç‚¹ç¼–å·æ˜¯1~n
for (int i = 1; i <= n; i ++ )
{
    p[i] = i;
    d[i] = 0;
}
// åˆå¹¶aå’Œbæ‰€åœ¨çš„ä¸¤ä¸ªé›†åˆï¼š
p[find(a)] = find(b);d[find(a)] = distance; // æ ¹æ®å…·ä½“é—®é¢˜ï¼Œåˆå§‹åŒ–find(a)çš„åç§»é‡
```

## å † 

```cpp
// h[N]å­˜å‚¨å †ä¸­çš„å€¼, h[1]æ˜¯å †é¡¶ï¼Œxçš„å·¦å„¿å­æ˜¯2x, å³å„¿å­æ˜¯2x + 1
// ph[k]å­˜å‚¨ç¬¬kä¸ªæ’å…¥çš„ç‚¹åœ¨å †ä¸­çš„ä½ç½®
// hp[k]å­˜å‚¨å †ä¸­ä¸‹æ ‡æ˜¯kçš„ç‚¹æ˜¯ç¬¬å‡ ä¸ªæ’å…¥çš„
int h[N], ph[N], hp[N], size;
// äº¤æ¢ä¸¤ä¸ªç‚¹ï¼ŒåŠå…¶æ˜ å°„å…³ç³»
void heap_swap(int a, int b)
{
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a], hp[b]);
    swap(h[a], h[b]);
}
void down(int u)
{
    int t = u;
    if (u * 2 <= size && h[u * 2] < h[t]) t = u * 2;
    if (u * 2 + 1 <= size && h[u * 2 + 1] < h[t]) t = u * 2 + 1;
    if (u != t)
    {
        heap_swap(u, t);
        down(t);
    }
}
void up(int u)
{
    while (u / 2 && h[u] < h[u / 2])
    {
        heap_swap(u, u / 2);
        u >>= 1;
    }
}
// O(n)å»ºå †
for (int i = n / 2; i; i -- ) down(i);
```

## STL

### vector, å˜é•¿æ•°ç»„ï¼Œå€å¢çš„æ€æƒ³

â€‹    size()  è¿”å›å…ƒç´ ä¸ªæ•°
â€‹    empty()  è¿”å›æ˜¯å¦ä¸ºç©º
â€‹    clear()  æ¸…ç©º
â€‹    front()/back()
â€‹    push_back()/pop_back()
â€‹    begin()/end()
â€‹    æ”¯æŒæ¯”è¾ƒè¿ç®—ï¼ŒæŒ‰å­—å…¸åº

### stringï¼Œå­—ç¬¦ä¸²

â€‹    size()/length()  è¿”å›å­—ç¬¦ä¸²é•¿åº¦
â€‹    empty()
â€‹    clear()
â€‹    substr(èµ·å§‹ä¸‹æ ‡ï¼Œ(å­ä¸²é•¿åº¦))  è¿”å›å­ä¸²
â€‹    c_str()  è¿”å›å­—ç¬¦ä¸²æ‰€åœ¨å­—ç¬¦æ•°ç»„çš„èµ·å§‹åœ°å€

### queue, é˜Ÿåˆ—

â€‹    size()
â€‹    empty()
â€‹    push()  å‘é˜Ÿå°¾æ’å…¥ä¸€ä¸ªå…ƒç´ 
â€‹    front()  è¿”å›é˜Ÿå¤´å…ƒç´ 
â€‹    back()  è¿”å›é˜Ÿå°¾å…ƒç´ 
â€‹    pop()  å¼¹å‡ºé˜Ÿå¤´å…ƒç´ 

### priority_queue, ä¼˜å…ˆé˜Ÿåˆ—ï¼Œé»˜è®¤æ˜¯å¤§æ ¹å †

â€‹    size()
â€‹    empty()
â€‹    push()  æ’å…¥ä¸€ä¸ªå…ƒç´ 
â€‹    top()  è¿”å›å †é¡¶å…ƒç´ 
â€‹    pop()  å¼¹å‡ºå †é¡¶å…ƒç´ 
â€‹    å®šä¹‰æˆå°æ ¹å †çš„æ–¹å¼ï¼špriority_queue<int, vector<int>, greater<int>> q;

### stack, æ ˆ

â€‹    size()
â€‹    empty()
â€‹    push()  å‘æ ˆé¡¶æ’å…¥ä¸€ä¸ªå…ƒç´ 
â€‹    top()  è¿”å›æ ˆé¡¶å…ƒç´ 
â€‹    pop()  å¼¹å‡ºæ ˆé¡¶å…ƒç´ 

### deque, åŒç«¯é˜Ÿåˆ—

â€‹    size()
â€‹    empty()
â€‹    clear()
â€‹    front()/back()
â€‹    push_back()/pop_back()
â€‹    push_front()/pop_front()
â€‹    begin()/end()

### set, map, multiset, multimap, åŸºäºå¹³è¡¡äºŒå‰æ ‘ï¼ˆçº¢é»‘æ ‘ï¼‰ï¼ŒåŠ¨æ€ç»´æŠ¤æœ‰åºåºåˆ—

â€‹    size()
â€‹    empty()
â€‹    clear()
â€‹    begin()/end()
â€‹    ++, -- è¿”å›å‰é©±å’Œåç»§ï¼Œæ—¶é—´å¤æ‚åº¦ O(logn)

set/multiset
    insert()  æ’å…¥ä¸€ä¸ªæ•°
    find()  æŸ¥æ‰¾ä¸€ä¸ªæ•°
    count()  è¿”å›æŸä¸€ä¸ªæ•°çš„ä¸ªæ•°
    erase()
        (1) è¾“å…¥æ˜¯ä¸€ä¸ªæ•°xï¼Œåˆ é™¤æ‰€æœ‰x   O(k + logn)
        (2) è¾“å…¥ä¸€ä¸ªè¿­ä»£å™¨ï¼Œåˆ é™¤è¿™ä¸ªè¿­ä»£å™¨
    lower_bound()/upper_bound()
        lower_bound(x)  è¿”å›å¤§äºç­‰äºxçš„æœ€å°çš„æ•°çš„è¿­ä»£å™¨
        upper_bound(x)  è¿”å›å¤§äºxçš„æœ€å°çš„æ•°çš„è¿­ä»£å™¨
map/multimap
    insert()  æ’å…¥çš„æ•°æ˜¯ä¸€ä¸ªpair
    erase()  è¾“å…¥çš„å‚æ•°æ˜¯pairæˆ–è€…è¿­ä»£å™¨
    find()
    æ³¨æ„multimapä¸æ”¯æŒæ­¤æ“ä½œã€‚ æ—¶é—´å¤æ‚åº¦æ˜¯ O(logn)
    lower_bound()/upper_bound()

unordered_set, unordered_map, unordered_multiset, unordered_multimap, å“ˆå¸Œè¡¨
    å’Œä¸Šé¢ç±»ä¼¼ï¼Œå¢åˆ æ”¹æŸ¥çš„æ—¶é—´å¤æ‚åº¦æ˜¯ O(1)
    ä¸æ”¯æŒ lower_bound()/upper_bound()ï¼Œ è¿­ä»£å™¨çš„++ï¼Œ--

### bitset, åœ§ä½

â€‹    bitset<10000> s;
â€‹    ~, &, |, ^
â€‹    >>, <<
â€‹    ==, !=
â€‹    []

count()  è¿”å›æœ‰å¤šå°‘ä¸ª1

any()  åˆ¤æ–­æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ª1
none()  åˆ¤æ–­æ˜¯å¦å…¨ä¸º0

set()  æŠŠæ‰€æœ‰ä½ç½®æˆ1
set(k, v)  å°†ç¬¬kä½å˜æˆv
reset()  æŠŠæ‰€æœ‰ä½å˜æˆ0
flip()  ç­‰ä»·äº~
flip(k) æŠŠç¬¬kä½å–å

# æœç´¢å’Œå›¾è®º

## æ ‘ä¸å›¾çš„å­˜å‚¨

### (2) é‚»æ¥è¡¨ï¼š

```c++
// å¯¹äºæ¯ä¸ªç‚¹kï¼Œå¼€ä¸€ä¸ªå•é“¾è¡¨ï¼Œå­˜å‚¨kæ‰€æœ‰å¯ä»¥èµ°åˆ°çš„ç‚¹ã€‚h[k]å­˜å‚¨è¿™ä¸ªå•é“¾è¡¨çš„å¤´ç»“ç‚¹
int h[N], e[N], ne[N], idx;
// æ·»åŠ ä¸€æ¡è¾¹a->b
void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}
// åˆå§‹åŒ–
idx = 0;
memset(h, -1, sizeof h);
```

## æ ‘ä¸å›¾çš„éå†

### (2) å®½åº¦ä¼˜å…ˆéå† 

```c++
queue<int> q;
st[1] = true; // è¡¨ç¤º1å·ç‚¹å·²ç»è¢«éå†è¿‡
q.push(1);

while (q.size())
{
    int t = q.front();
    q.pop();

for (int i = h[t]; i != -1; i = ne[i])
{
    int j = e[i];
    if (!st[j])
    {
        st[j] = true; // è¡¨ç¤ºç‚¹jå·²ç»è¢«éå†è¿‡
        q.push(j);
    }
}

}
```

## æ‹“æ‰‘æ’åº

æ—¶é—´å¤æ‚åº¦ O(n+m)ğ‘›è¡¨ç¤ºç‚¹æ•°ï¼Œmè¡¨ç¤ºè¾¹æ•°

```c++
bool topsort()
{
    int hh = 0, tt = -1;
// d[i] å­˜å‚¨ç‚¹içš„å…¥åº¦
for (int i = 1; i <= n; i ++ )
    if (!d[i])
        q[ ++ tt] = i;

while (hh <= tt)
{
    int t = q[hh ++ ];
â€‹    for (int i = h[t]; i != -1; i = ne[i])
â€‹    {
â€‹        int j = e[i];
â€‹        if (-- d[j] == 0)
â€‹            q[ ++ tt] = j;
â€‹    }
}
// å¦‚æœæ‰€æœ‰ç‚¹éƒ½å…¥é˜Ÿäº†ï¼Œè¯´æ˜å­˜åœ¨æ‹“æ‰‘åºåˆ—ï¼›å¦åˆ™ä¸å­˜åœ¨æ‹“æ‰‘åºåˆ—ã€‚
return tt == n - 1;
}
```

## æœ´ç´ dijkstraç®—æ³• æ—¶é—´å¤æ‚æ˜¯ O(n2+m)

ğ‘‚(ğ‘›^2+ğ‘š), nè¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•°

```c++
int g[N][N];  // å­˜å‚¨æ¯æ¡è¾¹
int dist[N];  // å­˜å‚¨1å·ç‚¹åˆ°æ¯ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»
bool st[N];   // å­˜å‚¨æ¯ä¸ªç‚¹çš„æœ€çŸ­è·¯æ˜¯å¦å·²ç»ç¡®å®š
// æ±‚1å·ç‚¹åˆ°nå·ç‚¹çš„æœ€çŸ­è·¯ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™è¿”å›-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

for (int i = 0; i < n - 1; i ++ )
{
    int t = -1;     // åœ¨è¿˜æœªç¡®å®šæœ€çŸ­è·¯çš„ç‚¹ä¸­ï¼Œå¯»æ‰¾è·ç¦»æœ€å°çš„ç‚¹
    for (int j = 1; j <= n; j ++ )
        if (!st[j] && (t == -1 || dist[t] > dist[j]))
            t = j;

â€‹    // ç”¨tæ›´æ–°å…¶ä»–ç‚¹çš„è·ç¦»
â€‹    for (int j = 1; j <= n; j ++ )
â€‹        dist[j] = min(dist[j], dist[t] + g[t][j]);

â€‹    st[t] = true;
}

if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];

}
```

## å †ä¼˜åŒ–ç‰ˆdijkstra

æ—¶é—´å¤æ‚åº¦ O(mlogn), n è¡¨ç¤ºç‚¹æ•°ï¼Œm è¡¨ç¤ºè¾¹æ•°

```c++
typedef pair<int, int> PII;
int n;      // ç‚¹çš„æ•°é‡
int h[N], w[N], e[N], ne[N], idx;       // é‚»æ¥è¡¨å­˜å‚¨æ‰€æœ‰è¾¹
int dist[N];        // å­˜å‚¨æ‰€æœ‰ç‚¹åˆ°1å·ç‚¹çš„è·ç¦»
bool st[N];     // å­˜å‚¨æ¯ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»æ˜¯å¦å·²ç¡®å®š
// æ±‚1å·ç‚¹åˆ°nå·ç‚¹çš„æœ€çŸ­è·ç¦»ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™è¿”å›-1
int dijkstra()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
    priority_queue<PII, vector<PII>, greater<PII>> heap;
    heap.push({0, 1});      // firstå­˜å‚¨è·ç¦»ï¼Œsecondå­˜å‚¨èŠ‚ç‚¹ç¼–å·
while (heap.size())
{
    auto t = heap.top();
    heap.pop();
â€‹    int ver = t.second, distance = t.first;
â€‹    if (st[ver]) continue;
â€‹    st[ver] = true;

â€‹    for (int i = h[ver]; i != -1; i = ne[i])
â€‹    {
â€‹        int j = e[i];
â€‹        if (dist[j] > distance + w[i])
â€‹        {
â€‹            dist[j] = distance + w[i];
â€‹            heap.push({dist[j], j});
â€‹        }
â€‹    }
}
if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];

}
```

## Bellman-Fordç®—æ³•

æ—¶é—´å¤æ‚åº¦ O(nm)

```c++
int n, m;       // nè¡¨ç¤ºç‚¹æ•°ï¼Œmè¡¨ç¤ºè¾¹æ•°
int dist[N];        // dist[x]å­˜å‚¨1åˆ°xçš„æœ€çŸ­è·¯è·ç¦»

struct Edge     // è¾¹ï¼Œaè¡¨ç¤ºå‡ºç‚¹ï¼Œbè¡¨ç¤ºå…¥ç‚¹ï¼Œwè¡¨ç¤ºè¾¹çš„æƒé‡
{
    int a, b, w;
}edges[M];
// æ±‚1åˆ°nçš„æœ€çŸ­è·¯è·ç¦»ï¼Œå¦‚æœæ— æ³•ä»1èµ°åˆ°nï¼Œåˆ™è¿”å›-1ã€‚
int bellman_ford()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;
// å¦‚æœç¬¬næ¬¡è¿­ä»£ä»ç„¶ä¼šæ¾å¼›ä¸‰è§’ä¸ç­‰å¼ï¼Œå°±è¯´æ˜å­˜åœ¨ä¸€æ¡é•¿åº¦æ˜¯n+1çš„æœ€çŸ­è·¯å¾„ï¼Œç”±æŠ½å±‰åŸç†ï¼Œè·¯å¾„ä¸­è‡³å°‘å­˜åœ¨ä¸¤ä¸ªç›¸åŒçš„ç‚¹ï¼Œè¯´æ˜å›¾ä¸­å­˜åœ¨è´Ÿæƒå›è·¯ã€‚
for (int i = 0; i < n; i ++ )
{
    for (int j = 0; j < m; j ++ )
    {
        int a = edges[j].a, b = edges[j].b, w = edges[j].w;
        if (dist[b] > dist[a] + w)
            dist[b] = dist[a] + w;
    }
}
if (dist[n] > 0x3f3f3f3f / 2) return -1;
return dist[n];
}
```

## spfa ç®—æ³•ï¼ˆé˜Ÿåˆ—ä¼˜åŒ–çš„Bellman-Fordç®—æ³•ï¼‰

æ—¶é—´å¤æ‚åº¦ å¹³å‡æƒ…å†µä¸‹ O(m)ï¼Œæœ€åæƒ…å†µä¸‹ O(nm)

```c++
int n;      // æ€»ç‚¹æ•°
int h[N], w[N], e[N], ne[N], idx;       // é‚»æ¥è¡¨å­˜å‚¨æ‰€æœ‰è¾¹
int dist[N];        // å­˜å‚¨æ¯ä¸ªç‚¹åˆ°1å·ç‚¹çš„æœ€çŸ­è·ç¦»
bool st[N];     // å­˜å‚¨æ¯ä¸ªç‚¹æ˜¯å¦åœ¨é˜Ÿåˆ—ä¸­
// æ±‚1å·ç‚¹åˆ°nå·ç‚¹çš„æœ€çŸ­è·¯è·ç¦»ï¼Œå¦‚æœä»1å·ç‚¹æ— æ³•èµ°åˆ°nå·ç‚¹åˆ™è¿”å›-1
int spfa()
{
    memset(dist, 0x3f, sizeof dist);
    dist[1] = 0;

queue<int> q;
q.push(1);
st[1] = true;
while (q.size())
{
    auto t = q.front();
    q.pop();
â€‹    st[t] = false;
â€‹    for (int i = h[t]; i != -1; i = ne[i])
â€‹    {
â€‹        int j = e[i];
â€‹        if (dist[j] > dist[t] + w[i])
â€‹        {
â€‹            dist[j] = dist[t] + w[i];
â€‹            if (!st[j])     // å¦‚æœé˜Ÿåˆ—ä¸­å·²å­˜åœ¨jï¼Œåˆ™ä¸éœ€è¦å°†jé‡å¤æ’å…¥
â€‹            {
â€‹                q.push(j);
â€‹                st[j] = true;
â€‹            }
â€‹        }
â€‹    }
}
if (dist[n] == 0x3f3f3f3f) return -1;
return dist[n];
}
```

## spfaåˆ¤æ–­å›¾ä¸­æ˜¯å¦å­˜åœ¨è´Ÿç¯

æ—¶é—´å¤æ‚åº¦æ˜¯ O(nm)

```c++
int n;      // æ€»ç‚¹æ•°
int h[N], w[N], e[N], ne[N], idx;       // é‚»æ¥è¡¨å­˜å‚¨æ‰€æœ‰è¾¹
int dist[N], cnt[N];        // dist[x]å­˜å‚¨1å·ç‚¹åˆ°xçš„æœ€çŸ­è·ç¦»ï¼Œcnt[x]å­˜å‚¨1åˆ°xçš„æœ€çŸ­è·¯ä¸­ç»è¿‡çš„ç‚¹æ•°
bool st[N];     // å­˜å‚¨æ¯ä¸ªç‚¹æ˜¯å¦åœ¨é˜Ÿåˆ—ä¸­
// å¦‚æœå­˜åœ¨è´Ÿç¯ï¼Œåˆ™è¿”å›trueï¼Œå¦åˆ™è¿”å›falseã€‚
bool spfa()
{
    // ä¸éœ€è¦åˆå§‹åŒ–distæ•°ç»„
    // åŸç†ï¼šå¦‚æœæŸæ¡æœ€çŸ­è·¯å¾„ä¸Šæœ‰nä¸ªç‚¹ï¼ˆé™¤äº†è‡ªå·±ï¼‰ï¼Œé‚£ä¹ˆåŠ ä¸Šè‡ªå·±ä¹‹åä¸€å…±æœ‰n+1ä¸ªç‚¹ï¼Œç”±æŠ½å±‰åŸç†ä¸€å®šæœ‰ä¸¤ä¸ªç‚¹ç›¸åŒï¼Œæ‰€ä»¥å­˜åœ¨ç¯ã€‚
    queue<int> q;
    for (int i = 1; i <= n; i ++ )
    {
        q.push(i);
        st[i] = true;
    }
    while (q.size())
    {
        auto t = q.front();
        q.pop();
        st[t] = false;
        for (int i = h[t]; i != -1; i = ne[i])
        {
            int j = e[i];
            if (dist[j] > dist[t] + w[i])
            {
                dist[j] = dist[t] + w[i];
                cnt[j] = cnt[t] + 1;
                if (cnt[j] >= n) return true;       // å¦‚æœä»1å·ç‚¹åˆ°xçš„æœ€çŸ­è·¯ä¸­åŒ…å«è‡³å°‘nä¸ªç‚¹ï¼ˆä¸åŒ…æ‹¬è‡ªå·±ï¼‰ï¼Œåˆ™è¯´æ˜å­˜åœ¨ç¯
                if (!st[j])
                {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return false;
}
```

## floyd

åˆå§‹åŒ–ï¼š

```c++
    for (int i = 1; i <= n; i ++ )
â€‹        for (int j = 1; j <= n; j ++ )
â€‹            if (i == j) d[i][j] = 0;
â€‹            else d[i][j] = INF;
// ç®—æ³•ç»“æŸåï¼Œd[a][b]è¡¨ç¤ºaåˆ°bçš„æœ€çŸ­è·ç¦»
void floyd()
{
    for (int k = 1; k <= n; k ++ )
        for (int i = 1; i <= n; i ++ )
            for (int j = 1; j <= n; j ++ )
                d[i][j] = min(d[i][j], d[i][k] + d[k][j]);
}
```

## æœ´ç´ ç‰ˆprim

æ—¶é—´å¤æ‚åº¦æ˜¯ O(n2+m)

```c++
int n;      // nè¡¨ç¤ºç‚¹æ•°
int g[N][N];        // é‚»æ¥çŸ©é˜µï¼Œå­˜å‚¨æ‰€æœ‰è¾¹
int dist[N];        // å­˜å‚¨å…¶ä»–ç‚¹åˆ°å½“å‰æœ€å°ç”Ÿæˆæ ‘çš„è·ç¦»
bool st[N];     // å­˜å‚¨æ¯ä¸ªç‚¹æ˜¯å¦å·²ç»åœ¨ç”Ÿæˆæ ‘ä¸­
// å¦‚æœå›¾ä¸è¿é€šï¼Œåˆ™è¿”å›INF(å€¼æ˜¯0x3f3f3f3f), å¦åˆ™è¿”å›æœ€å°ç”Ÿæˆæ ‘çš„æ ‘è¾¹æƒé‡ä¹‹å’Œ
int prim()
{
    memset(dist, 0x3f, sizeof dist);
    int res = 0;
    for (int i = 0; i < n; i ++ )
    {
        int t = -1;
        for (int j = 1; j <= n; j ++ )
            if (!st[j] && (t == -1 || dist[t] > dist[j]))
                t = j;
        if (i && dist[t] == INF) return INF;
        if (i) res += dist[t];
        st[t] = true;
    
        for (int j = 1; j <= n; j ++ ) dist[j] = min(dist[j], g[t][j]);
    } 
    return res;
}
```

## Kruskalç®—æ³•

```c++
æ—¶é—´å¤æ‚åº¦æ˜¯ O(mlogm
int n, m;       // næ˜¯ç‚¹æ•°ï¼Œmæ˜¯è¾¹æ•°
int p[N];       // å¹¶æŸ¥é›†çš„çˆ¶èŠ‚ç‚¹æ•°ç»„
struct Edge     // å­˜å‚¨è¾¹
{
    int a, b, w;
    bool operator< (const Edge &W)const
    {
        return w < W.w;
    }
}edges[M];
int find(int x)     // å¹¶æŸ¥é›†æ ¸å¿ƒæ“ä½œ
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}
int kruskal()
{
    sort(edges, edges + m);
    for (int i = 1; i <= n; i ++ ) p[i] = i;    // åˆå§‹åŒ–å¹¶æŸ¥é›†
    int res = 0, cnt = 0;
    for (int i = 0; i < m; i ++ )
    {
        int a = edges[i].a, b = edges[i].b, w = edges[i].w;
        a = find(a), b = find(b);
        if (a != b)     // å¦‚æœä¸¤ä¸ªè¿é€šå—ä¸è¿é€šï¼Œåˆ™å°†è¿™ä¸¤ä¸ªè¿é€šå—åˆå¹¶
        {
            p[a] = b;
            res += w;
            cnt ++ ;
        }
    }
    if (cnt < n - 1) return INF;
    return res;
}
```

## æŸ“è‰²æ³•åˆ¤åˆ«äºŒåˆ†å›¾

æ—¶é—´å¤æ‚åº¦æ˜¯ O(n+m)

```c++
int n;      // nè¡¨ç¤ºç‚¹æ•°
int h[N], e[M], ne[M], idx;     // é‚»æ¥è¡¨å­˜å‚¨å›¾
int color[N];       // è¡¨ç¤ºæ¯ä¸ªç‚¹çš„é¢œè‰²ï¼Œ-1è¡¨ç¤ºæœªæŸ“è‰²ï¼Œ0è¡¨ç¤ºç™½è‰²ï¼Œ1è¡¨ç¤ºé»‘è‰²
// å‚æ•°ï¼šuè¡¨ç¤ºå½“å‰èŠ‚ç‚¹ï¼Œcè¡¨ç¤ºå½“å‰ç‚¹çš„é¢œè‰²
bool dfs(int u, int c)
{
    color[u] = c;
    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (color[j] == -1)
        {
            if (!dfs(j, !c)) return false;
        }
        else if (color[j] == c) return false;
    }
    return true;
}
bool check()
{
    memset(color, -1, sizeof color);
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (color[i] == -1)
            if (!dfs(i, 0))
            {
                flag = false;
                break;
            }
    return flag;
}
```

## åŒˆç‰™åˆ©

æ—¶é—´å¤æ‚åº¦æ˜¯ O(nm)

```c++
int n1, n2;     // n1è¡¨ç¤ºç¬¬ä¸€ä¸ªé›†åˆä¸­çš„ç‚¹æ•°ï¼Œn2è¡¨ç¤ºç¬¬äºŒä¸ªé›†åˆä¸­çš„ç‚¹æ•°
int h[N], e[M], ne[M], idx;     // é‚»æ¥è¡¨å­˜å‚¨æ‰€æœ‰è¾¹ï¼ŒåŒˆç‰™åˆ©ç®—æ³•ä¸­åªä¼šç”¨åˆ°ä»ç¬¬ä¸€ä¸ªé›†åˆæŒ‡å‘ç¬¬äºŒä¸ªé›†åˆçš„è¾¹ï¼Œæ‰€ä»¥è¿™é‡Œåªç”¨å­˜ä¸€ä¸ªæ–¹å‘çš„è¾¹
int match[N];       // å­˜å‚¨ç¬¬äºŒä¸ªé›†åˆä¸­çš„æ¯ä¸ªç‚¹å½“å‰åŒ¹é…çš„ç¬¬ä¸€ä¸ªé›†åˆä¸­çš„ç‚¹æ˜¯å“ªä¸ª
bool st[N];     // è¡¨ç¤ºç¬¬äºŒä¸ªé›†åˆä¸­çš„æ¯ä¸ªç‚¹æ˜¯å¦å·²ç»è¢«éå†è¿‡
bool find(int x)
{
    for (int i = h[x]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!st[j])
        {
            st[j] = true;
            if (match[j] == 0 || find(match[j]))
            {
                match[j] = x;
                return true;
            }
        }
    }
    return false;
}
// æ±‚æœ€å¤§åŒ¹é…æ•°ï¼Œä¾æ¬¡æšä¸¾ç¬¬ä¸€ä¸ªé›†åˆä¸­çš„æ¯ä¸ªç‚¹èƒ½å¦åŒ¹é…ç¬¬äºŒä¸ªé›†åˆä¸­çš„ç‚¹
int res = 0;
for (int i = 1; i <= n1; i ++ )
{
    memset(st, false, sizeof st);
    if (find(i)) res ++ ;
}
```

# æ•°è®º

## è¯•é™¤æ³•åˆ†è§£è´¨å› æ•°

```c++
void divide(int x)
{
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0)
        {
            int s = 0;
            while (x % i == 0) x /= i, s ++ ;
            cout << i << ' ' << s << endl;
        }
    if (x > 1) cout << x << ' ' << 1 << endl;
    cout << endl;
}
```

## æœ´ç´ ç­›æ³•æ±‚ç´ æ•° 

```c++
int primes[N], cnt;     // primes[]å­˜å‚¨æ‰€æœ‰ç´ æ•°
bool st[N];         // st[x]å­˜å‚¨xæ˜¯å¦è¢«ç­›æ‰
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (st[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            st[j] = true;
    }
}
```

## çº¿æ€§ç­›æ³•æ±‚ç´ æ•° 

```c++
int primes[N], cnt;     // primes[]å­˜å‚¨æ‰€æœ‰ç´ æ•°
bool st[N];         // st[x]å­˜å‚¨xæ˜¯å¦è¢«ç­›æ‰
void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;
            if (i % primes[j] == 0) break;
        }
    }
}
```

## åŸƒæ°ç­›

```cpp
void sieve(int n)
{
    int i,j,k;
    k=0;
    memset(vis,0,sizeof(int)*maxn);
    vis[0]=vis[1]=1;
    for(i=2;i<=n;i++)
    {
        if(vis[i]==0)
        {
            prime[k++]=i;
            for(j=2;i*j<=n;j++)
                vis[i*j]=1;
        }
    }
}
```

## å¿«é€Ÿå¹‚ 

æ±‚ m^k mod pï¼Œæ—¶é—´å¤æ‚åº¦ O(logk)ã€‚

```c++
int qmi(int m, int k, int p)
{
    int res = 1 % p, t = m;
    while (k)
    {
        if (k&1) res = res * t % p;
        t = t * t % p;
        k >>= 1;
    }
    return res;
}
```

## æ‰©å±•æ¬§å‡ é‡Œå¾—ç®—æ³•

```c++
// æ±‚x, yï¼Œä½¿å¾—ax + by = gcd(a, b)
int exgcd(int a, int b, int &x, int &y)
{
    if (!b)
    {
        x = 1; y = 0;
        return a;
    }
    int d = exgcd(b, a % b, y, x);
    y -= (a/b) * x;
    return d;
}
```

## é€’æ¨æ³•æ±‚ç»„åˆæ•°

```c++
// c[a][b] è¡¨ç¤ºä»aä¸ªè‹¹æœä¸­é€‰bä¸ªçš„æ–¹æ¡ˆæ•°
for (int i = 0; i < N; i ++ )
    for (int j = 0; j <= i; j ++ )
        if (!j) c[i][j] = 1;
        else c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % mod;
```

